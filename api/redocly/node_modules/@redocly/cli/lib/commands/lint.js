"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleLint = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
function handleLint(argv, version) {
    return __awaiter(this, void 0, void 0, function* () {
        if (argv.config && !openapi_core_1.doesYamlFileExist(argv.config)) {
            return utils_1.exitWithError('Please, provide valid path to the configuration file');
        }
        const config = yield utils_1.loadConfigAndHandleErrors({
            configPath: argv.config,
            customExtends: argv.extends,
            processRawConfig: lintConfigCallback(argv, version),
        });
        const apis = yield utils_1.getFallbackApisOrExit(argv.apis, config);
        if (argv['generate-ignore-file']) {
            config.styleguide.ignore = {}; // clear ignore
        }
        const totals = { errors: 0, warnings: 0, ignored: 0 };
        let totalIgnored = 0;
        // TODO: use shared externalRef resolver, blocked by preprocessors now as they can mutate documents
        for (const { path, alias } of apis) {
            try {
                const startedAt = perf_hooks_1.performance.now();
                const resolvedConfig = openapi_core_1.getMergedConfig(config, alias);
                const { styleguide } = resolvedConfig;
                styleguide.skipRules(argv['skip-rule']);
                styleguide.skipPreprocessors(argv['skip-preprocessor']);
                if (styleguide.recommendedFallback) {
                    process.stderr.write(`No configurations were provided -- using built in ${colorette_1.blue('recommended')} configuration by default.\n\n`);
                }
                process.stderr.write(colorette_1.gray(`validating ${path.replace(process.cwd(), '')}...\n`));
                const results = yield openapi_core_1.lint({
                    ref: path,
                    config: resolvedConfig,
                });
                const fileTotals = openapi_core_1.getTotals(results);
                totals.errors += fileTotals.errors;
                totals.warnings += fileTotals.warnings;
                totals.ignored += fileTotals.ignored;
                if (argv['generate-ignore-file']) {
                    for (const m of results) {
                        config.styleguide.addIgnore(m);
                        totalIgnored++;
                    }
                }
                else {
                    openapi_core_1.formatProblems(results, {
                        format: argv.format,
                        maxProblems: argv['max-problems'],
                        totals: fileTotals,
                        version,
                    });
                }
                const elapsed = utils_1.getExecutionTime(startedAt);
                process.stderr.write(colorette_1.gray(`${path.replace(process.cwd(), '')}: validated in ${elapsed}\n\n`));
            }
            catch (e) {
                utils_1.handleError(e, path);
            }
        }
        if (argv['generate-ignore-file']) {
            config.styleguide.saveIgnore();
            process.stderr.write(`Generated ignore file with ${totalIgnored} ${utils_1.pluralize('problem', totalIgnored)}.\n\n`);
        }
        else {
            utils_1.printLintTotals(totals, apis.length);
        }
        utils_1.printUnusedWarnings(config.styleguide);
        // defer process exit to allow STDOUT pipe to flush
        // see https://github.com/nodejs/node-v0.x-archive/issues/3737#issuecomment-19156072
        process.once('exit', () => process.exit(totals.errors === 0 || argv['generate-ignore-file'] ? 0 : 1));
    });
}
exports.handleLint = handleLint;
function lintConfigCallback(argv, version) {
    if (argv['lint-config'] === 'off') {
        return;
    }
    if (argv.format === 'json') {
        // we can't print config lint results as it will break json output
        return;
    }
    return (config) => __awaiter(this, void 0, void 0, function* () {
        const { 'max-problems': maxProblems, format } = argv;
        const configPath = openapi_core_1.findConfig(argv.config) || '';
        const stringYaml = openapi_core_1.stringifyYaml(config);
        const configContent = openapi_core_1.makeDocumentFromString(stringYaml, configPath);
        const problems = yield openapi_core_1.lintConfig({
            document: configContent,
            severity: argv['lint-config'],
        });
        const fileTotals = openapi_core_1.getTotals(problems);
        openapi_core_1.formatProblems(problems, {
            format,
            maxProblems,
            totals: fileTotals,
            version,
        });
        utils_1.printConfigLintTotals(fileTotals);
    });
}
