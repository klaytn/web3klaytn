"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleBundle = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const fs_1 = require("fs");
function handleBundle(argv, version) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield utils_1.loadConfigAndHandleErrors({
            configPath: argv.config,
            customExtends: argv.extends,
        });
        const removeUnusedComponents = argv['remove-unused-components'] ||
            ((_c = (_b = (_a = config.rawConfig) === null || _a === void 0 ? void 0 : _a.styleguide) === null || _b === void 0 ? void 0 : _b.decorators) === null || _c === void 0 ? void 0 : _c.hasOwnProperty('remove-unused-components'));
        const apis = yield utils_1.getFallbackApisOrExit(argv.apis, config);
        const totals = { errors: 0, warnings: 0, ignored: 0 };
        const maxProblems = argv['max-problems'];
        for (const { path, alias } of apis) {
            try {
                const startedAt = perf_hooks_1.performance.now();
                const resolvedConfig = openapi_core_1.getMergedConfig(config, alias);
                const { styleguide } = resolvedConfig;
                styleguide.skipRules(argv['skip-rule']);
                styleguide.skipPreprocessors(argv['skip-preprocessor']);
                styleguide.skipDecorators(argv['skip-decorator']);
                if (argv.lint) {
                    if (config.styleguide.recommendedFallback) {
                        process.stderr.write(`No configurations were provided -- using built in ${colorette_1.blue('recommended')} configuration by default.\n\n`);
                    }
                    const results = yield openapi_core_1.lint({
                        ref: path,
                        config: resolvedConfig,
                    });
                    const fileLintTotals = openapi_core_1.getTotals(results);
                    totals.errors += fileLintTotals.errors;
                    totals.warnings += fileLintTotals.warnings;
                    totals.ignored += fileLintTotals.ignored;
                    openapi_core_1.formatProblems(results, {
                        format: argv.format || 'codeframe',
                        totals: fileLintTotals,
                        version,
                        maxProblems,
                    });
                    utils_1.printLintTotals(fileLintTotals, 2);
                }
                process.stderr.write(colorette_1.gray(`bundling ${path}...\n`));
                const _f = yield openapi_core_1.bundle({
                    config: resolvedConfig,
                    ref: path,
                    dereference: argv.dereferenced,
                    removeUnusedComponents,
                    keepUrlRefs: argv['keep-url-references'],
                }), { bundle: result, problems } = _f, meta = __rest(_f, ["bundle", "problems"]);
                const fileTotals = openapi_core_1.getTotals(problems);
                const { outputFile, ext } = utils_1.getOutputFileName(path, apis.length, argv.output, argv.ext);
                if (fileTotals.errors === 0 || argv.force) {
                    if (!argv.output) {
                        const output = utils_1.dumpBundle(result.parsed, argv.ext || 'yaml', argv.dereferenced);
                        process.stdout.write(output);
                    }
                    else {
                        const output = utils_1.dumpBundle(result.parsed, ext, argv.dereferenced);
                        utils_1.saveBundle(outputFile, output);
                    }
                }
                totals.errors += fileTotals.errors;
                totals.warnings += fileTotals.warnings;
                totals.ignored += fileTotals.ignored;
                openapi_core_1.formatProblems(problems, {
                    format: argv.format,
                    maxProblems,
                    totals: fileTotals,
                    version,
                });
                if (argv.metafile) {
                    if (apis.length > 1) {
                        process.stderr.write(colorette_1.yellow(`[WARNING] "--metafile" cannot be used with multiple apis. Skipping...`));
                    }
                    {
                        fs_1.writeFileSync(argv.metafile, JSON.stringify(meta), 'utf-8');
                    }
                }
                const elapsed = utils_1.getExecutionTime(startedAt);
                if (fileTotals.errors > 0) {
                    if (argv.force) {
                        process.stderr.write(`â“ Created a bundle for ${colorette_1.blue(path)} at ${colorette_1.blue(outputFile)} with errors ${colorette_1.green(elapsed)}.\n${colorette_1.yellow('Errors ignored because of --force')}.\n`);
                    }
                    else {
                        process.stderr.write(`âŒ Errors encountered while bundling ${colorette_1.blue(path)}: bundle not created (use --force to ignore errors).\n`);
                    }
                }
                else {
                    process.stderr.write(`ðŸ“¦ Created a bundle for ${colorette_1.blue(path)} at ${colorette_1.blue(outputFile)} ${colorette_1.green(elapsed)}.\n`);
                }
                const removedCount = (_e = (_d = meta.visitorsData) === null || _d === void 0 ? void 0 : _d['remove-unused-components']) === null || _e === void 0 ? void 0 : _e.removedCount;
                if (removedCount) {
                    process.stderr.write(colorette_1.gray(`ðŸ§¹ Removed ${removedCount} unused components.\n`));
                }
            }
            catch (e) {
                utils_1.handleError(e, path);
            }
        }
        utils_1.printUnusedWarnings(config.styleguide);
        // defer process exit to allow STDOUT pipe to flush
        // see https://github.com/nodejs/node-v0.x-archive/issues/3737#issuecomment-19156072
        process.once('exit', () => process.exit(totals.errors === 0 || argv.force ? 0 : 1));
    });
}
exports.handleBundle = handleBundle;
