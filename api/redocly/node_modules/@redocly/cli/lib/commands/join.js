"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleJoin = void 0;
const path = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const isEqual = require('lodash.isequal');
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const js_utils_1 = require("../js-utils");
const types_1 = require("./split/types");
const COMPONENTS = 'components';
const Tags = 'tags';
const xTagGroups = 'x-tagGroups';
let potentialConflictsTotal = 0;
function handleJoin(argv, packageVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        const startedAt = perf_hooks_1.performance.now();
        if (argv.apis.length < 2) {
            return utils_1.exitWithError(`At least 2 apis should be provided. \n\n`);
        }
        const { 'prefix-components-with-info-prop': prefixComponentsWithInfoProp, 'prefix-tags-with-filename': prefixTagsWithFilename, 'prefix-tags-with-info-prop': prefixTagsWithInfoProp, 'without-x-tag-groups': withoutXTagGroups, output: specFilename = 'openapi.yaml', } = argv;
        const usedTagsOptions = [
            prefixTagsWithFilename && 'prefix-tags-with-filename',
            prefixTagsWithInfoProp && 'prefix-tags-with-info-prop',
            withoutXTagGroups && 'without-x-tag-groups',
        ].filter(Boolean);
        if (usedTagsOptions.length > 1) {
            return utils_1.exitWithError(`You use ${colorette_1.yellow(usedTagsOptions.join(', '))} together.\nPlease choose only one! \n\n`);
        }
        const config = yield utils_1.loadConfigAndHandleErrors();
        const apis = yield utils_1.getFallbackApisOrExit(argv.apis, config);
        const externalRefResolver = new openapi_core_1.BaseResolver(config.resolve);
        const documents = yield Promise.all(apis.map(({ path }) => externalRefResolver.resolveDocument(null, path, true)));
        const bundleResults = yield Promise.all(documents.map((document) => openapi_core_1.bundleDocument({
            document,
            config: config.styleguide,
            externalRefResolver,
        }).catch((e) => {
            utils_1.exitWithError(`${e.message}: ${colorette_1.blue(document.source.absoluteRef)}`);
        })));
        for (const { problems, bundle: document } of bundleResults) {
            const fileTotals = openapi_core_1.getTotals(problems);
            if (fileTotals.errors) {
                openapi_core_1.formatProblems(problems, {
                    totals: fileTotals,
                    version: document.parsed.version,
                });
                utils_1.exitWithError(`âŒ Errors encountered while bundling ${colorette_1.blue(document.source.absoluteRef)}: join will not proceed.\n`);
            }
        }
        for (const document of documents) {
            try {
                const version = openapi_core_1.detectOpenAPI(document.parsed);
                if (version !== openapi_core_1.OasVersion.Version3_0) {
                    return utils_1.exitWithError(`Only OpenAPI 3 is supported: ${colorette_1.blue(document.source.absoluteRef)} \n\n`);
                }
            }
            catch (e) {
                return utils_1.exitWithError(`${e.message}: ${colorette_1.blue(document.source.absoluteRef)}`);
            }
        }
        if (argv.lint) {
            for (const document of documents) {
                yield validateApi(document, config.styleguide, externalRefResolver, packageVersion);
            }
        }
        const joinedDef = {};
        const potentialConflicts = {
            tags: {},
            paths: {},
            components: {},
            xWebhooks: {},
        };
        addInfoSectionAndSpecVersion(documents, prefixComponentsWithInfoProp);
        for (const document of documents) {
            const openapi = document.parsed;
            const { tags, info } = openapi;
            const api = path.relative(process.cwd(), document.source.absoluteRef);
            const apiFilename = getApiFilename(api);
            const tagsPrefix = prefixTagsWithFilename
                ? apiFilename
                : getInfoPrefix(info, prefixTagsWithInfoProp, 'tags');
            const componentsPrefix = getInfoPrefix(info, prefixComponentsWithInfoProp, COMPONENTS);
            if (openapi.hasOwnProperty('x-tagGroups')) {
                process.stderr.write(colorette_1.yellow(`warning: x-tagGroups at ${colorette_1.blue(api)} will be skipped \n`));
            }
            const context = {
                api,
                apiFilename,
                tags,
                potentialConflicts,
                tagsPrefix,
                componentsPrefix,
            };
            if (tags) {
                populateTags(context);
            }
            collectServers(openapi);
            collectInfoDescriptions(openapi, context);
            collectExternalDocs(openapi, context);
            collectPaths(openapi, context);
            collectComponents(openapi, context);
            collectXWebhooks(openapi, context);
            if (componentsPrefix) {
                replace$Refs(openapi, componentsPrefix);
            }
        }
        iteratePotentialConflicts(potentialConflicts, withoutXTagGroups);
        const noRefs = true;
        if (potentialConflictsTotal) {
            return utils_1.exitWithError(`Please fix conflicts before running ${colorette_1.yellow('join')}.`);
        }
        utils_1.writeYaml(joinedDef, specFilename, noRefs);
        utils_1.printExecutionTime('join', startedAt, specFilename);
        function populateTags({ api, apiFilename, tags, potentialConflicts, tagsPrefix, componentsPrefix, }) {
            if (!joinedDef.hasOwnProperty(Tags)) {
                joinedDef[Tags] = [];
            }
            if (!potentialConflicts.tags.hasOwnProperty('all')) {
                potentialConflicts.tags['all'] = {};
            }
            if (withoutXTagGroups && !potentialConflicts.tags.hasOwnProperty('description')) {
                potentialConflicts.tags['description'] = {};
            }
            for (const tag of tags) {
                const entrypointTagName = addPrefix(tag.name, tagsPrefix);
                if (tag.description) {
                    tag.description = addComponentsPrefix(tag.description, componentsPrefix);
                }
                const tagDuplicate = joinedDef.tags.find((t) => t.name === entrypointTagName);
                if (tagDuplicate && withoutXTagGroups) {
                    // If tag already exist and `without-x-tag-groups` option,
                    // check if description are different for potential conflicts warning.
                    const isTagDescriptionNotEqual = tag.hasOwnProperty('description') && tagDuplicate.description !== tag.description;
                    potentialConflicts.tags.description[entrypointTagName].push(...(isTagDescriptionNotEqual ? [api] : []));
                }
                else if (!tagDuplicate) {
                    // Instead add tag to joinedDef if there no duplicate;
                    tag['x-displayName'] = tag['x-displayName'] || tag.name;
                    tag.name = entrypointTagName;
                    joinedDef.tags.push(tag);
                    if (withoutXTagGroups) {
                        potentialConflicts.tags.description[entrypointTagName] = [api];
                    }
                }
                if (!withoutXTagGroups) {
                    createXTagGroups(apiFilename);
                    if (!tagDuplicate) {
                        populateXTagGroups(entrypointTagName, getIndexGroup(apiFilename));
                    }
                }
                const doesEntrypointExist = !potentialConflicts.tags.all[entrypointTagName] ||
                    (potentialConflicts.tags.all[entrypointTagName] &&
                        !potentialConflicts.tags.all[entrypointTagName].includes(api));
                potentialConflicts.tags.all[entrypointTagName] = [
                    ...(potentialConflicts.tags.all[entrypointTagName] || []),
                    ...(!withoutXTagGroups && doesEntrypointExist ? [api] : []),
                ];
            }
        }
        function getIndexGroup(apiFilename) {
            return joinedDef[xTagGroups].findIndex((item) => item.name === apiFilename);
        }
        function createXTagGroups(apiFilename) {
            if (!joinedDef.hasOwnProperty(xTagGroups)) {
                joinedDef[xTagGroups] = [];
            }
            if (!joinedDef[xTagGroups].some((g) => g.name === apiFilename)) {
                joinedDef[xTagGroups].push({ name: apiFilename, tags: [] });
            }
            const indexGroup = getIndexGroup(apiFilename);
            if (!joinedDef[xTagGroups][indexGroup].hasOwnProperty(Tags)) {
                joinedDef[xTagGroups][indexGroup][Tags] = [];
            }
        }
        function populateXTagGroups(entrypointTagName, indexGroup) {
            if (!joinedDef[xTagGroups][indexGroup][Tags].find((t) => t.name === entrypointTagName)) {
                joinedDef[xTagGroups][indexGroup][Tags].push(entrypointTagName);
            }
        }
        function collectServers(openapi) {
            const { servers } = openapi;
            if (servers) {
                if (!joinedDef.hasOwnProperty('servers')) {
                    joinedDef['servers'] = [];
                }
                for (const server of servers) {
                    if (!joinedDef.servers.some((s) => s.url === server.url)) {
                        joinedDef.servers.push(server);
                    }
                }
            }
        }
        function collectInfoDescriptions(openapi, { apiFilename, componentsPrefix }) {
            const { info } = openapi;
            if (info === null || info === void 0 ? void 0 : info.description) {
                const groupIndex = joinedDef[xTagGroups] ? getIndexGroup(apiFilename) : -1;
                if (joinedDef.hasOwnProperty(xTagGroups) &&
                    groupIndex !== -1 &&
                    joinedDef[xTagGroups][groupIndex]['tags'] &&
                    joinedDef[xTagGroups][groupIndex]['tags'].length) {
                    joinedDef[xTagGroups][groupIndex]['description'] = addComponentsPrefix(info.description, componentsPrefix);
                }
            }
        }
        function collectExternalDocs(openapi, { api }) {
            const { externalDocs } = openapi;
            if (externalDocs) {
                if (joinedDef.hasOwnProperty('externalDocs')) {
                    process.stderr.write(colorette_1.yellow(`warning: skip externalDocs from ${colorette_1.blue(path.basename(api))} \n`));
                    return;
                }
                joinedDef['externalDocs'] = externalDocs;
            }
        }
        function collectPaths(openapi, { apiFilename, api, potentialConflicts, tagsPrefix, componentsPrefix }) {
            const { paths } = openapi;
            const operationsSet = new Set(js_utils_1.keysOf(types_1.OPENAPI3_METHOD));
            if (paths) {
                if (!joinedDef.hasOwnProperty('paths')) {
                    joinedDef['paths'] = {};
                }
                for (const path of js_utils_1.keysOf(paths)) {
                    if (!joinedDef.paths.hasOwnProperty(path)) {
                        joinedDef.paths[path] = {};
                    }
                    if (!potentialConflicts.paths.hasOwnProperty(path)) {
                        potentialConflicts.paths[path] = {};
                    }
                    const pathItem = paths[path];
                    for (const field of js_utils_1.keysOf(pathItem)) {
                        if (operationsSet.has(field)) {
                            collectPathOperation(pathItem, path, field);
                        }
                        if (field === 'servers') {
                            collectPathServers(pathItem, path);
                        }
                        if (field === 'parameters') {
                            collectPathParameters(pathItem, path);
                        }
                        if (typeof pathItem[field] === 'string') {
                            collectPathStringFields(pathItem, path, field);
                        }
                    }
                }
            }
            function collectPathStringFields(pathItem, path, field) {
                const fieldValue = pathItem[field];
                if (joinedDef.paths[path].hasOwnProperty(field) &&
                    joinedDef.paths[path][field] !== fieldValue) {
                    process.stderr.write(colorette_1.yellow(`warning: different ${field} values in ${path}\n`));
                    return;
                }
                joinedDef.paths[path][field] = fieldValue;
            }
            function collectPathServers(pathItem, path) {
                if (!pathItem.servers) {
                    return;
                }
                if (!joinedDef.paths[path].hasOwnProperty('servers')) {
                    joinedDef.paths[path].servers = [];
                }
                for (const server of pathItem.servers) {
                    let isFoundServer = false;
                    for (const pathServer of joinedDef.paths[path].servers) {
                        if (pathServer.url === server.url) {
                            if (!isServersEqual(pathServer, server)) {
                                utils_1.exitWithError(`Different server values for (${server.url}) in ${path}`);
                            }
                            isFoundServer = true;
                        }
                    }
                    if (!isFoundServer) {
                        joinedDef.paths[path].servers.push(server);
                    }
                }
            }
            function collectPathParameters(pathItem, path) {
                if (!pathItem.parameters) {
                    return;
                }
                if (!joinedDef.paths[path].hasOwnProperty('parameters')) {
                    joinedDef.paths[path].parameters = [];
                }
                for (const parameter of pathItem.parameters) {
                    let isFoundParameter = false;
                    for (const pathParameter of joinedDef.paths[path].parameters) {
                        if (pathParameter.name === parameter.name && pathParameter.in === parameter.in) {
                            if (!isEqual(pathParameter.schema, parameter.schema)) {
                                utils_1.exitWithError(`Different parameter schemas for (${parameter.name}) in ${path}`);
                            }
                            isFoundParameter = true;
                        }
                    }
                    if (!isFoundParameter) {
                        joinedDef.paths[path].parameters.push(parameter);
                    }
                }
            }
            function collectPathOperation(pathItem, path, operation) {
                const pathOperation = pathItem[operation];
                if (!pathOperation) {
                    return;
                }
                joinedDef.paths[path][operation] = pathOperation;
                potentialConflicts.paths[path][operation] = [
                    ...(potentialConflicts.paths[path][operation] || []),
                    api,
                ];
                const { operationId } = pathOperation;
                if (operationId) {
                    if (!potentialConflicts.paths.hasOwnProperty('operationIds')) {
                        potentialConflicts.paths['operationIds'] = {};
                    }
                    potentialConflicts.paths.operationIds[operationId] = [
                        ...(potentialConflicts.paths.operationIds[operationId] || []),
                        api,
                    ];
                }
                const { tags, security } = joinedDef.paths[path][operation];
                if (tags) {
                    joinedDef.paths[path][operation].tags = tags.map((tag) => addPrefix(tag, tagsPrefix));
                    populateTags({
                        api,
                        apiFilename,
                        tags: formatTags(tags),
                        potentialConflicts,
                        tagsPrefix,
                        componentsPrefix,
                    });
                }
                else {
                    joinedDef.paths[path][operation]['tags'] = [addPrefix('other', tagsPrefix || apiFilename)];
                    populateTags({
                        api,
                        apiFilename,
                        tags: formatTags(['other']),
                        potentialConflicts,
                        tagsPrefix: tagsPrefix || apiFilename,
                        componentsPrefix,
                    });
                }
                if (!security && openapi.hasOwnProperty('security')) {
                    joinedDef.paths[path][operation]['security'] = addSecurityPrefix(openapi.security, componentsPrefix);
                }
                else if (pathOperation.security) {
                    joinedDef.paths[path][operation].security = addSecurityPrefix(pathOperation.security, componentsPrefix);
                }
            }
        }
        function isServersEqual(serverOne, serverTwo) {
            if (serverOne.description === serverTwo.description) {
                return isEqual(serverOne.variables, serverTwo.variables);
            }
            return false;
        }
        function collectComponents(openapi, { api, potentialConflicts, componentsPrefix }) {
            const { components } = openapi;
            if (components) {
                if (!joinedDef.hasOwnProperty(COMPONENTS)) {
                    joinedDef[COMPONENTS] = {};
                }
                for (const [component, componentObj] of Object.entries(components)) {
                    if (!potentialConflicts[COMPONENTS].hasOwnProperty(component)) {
                        potentialConflicts[COMPONENTS][component] = {};
                        joinedDef[COMPONENTS][component] = {};
                    }
                    for (const item of Object.keys(componentObj)) {
                        const componentPrefix = addPrefix(item, componentsPrefix);
                        potentialConflicts.components[component][componentPrefix] = [
                            ...(potentialConflicts.components[component][item] || []),
                            { [api]: componentObj[item] },
                        ];
                        joinedDef.components[component][componentPrefix] = componentObj[item];
                    }
                }
            }
        }
        function collectXWebhooks(openapi, { apiFilename, api, potentialConflicts, tagsPrefix, componentsPrefix }) {
            const xWebhooks = 'x-webhooks';
            const openapiXWebhooks = openapi[xWebhooks];
            if (openapiXWebhooks) {
                if (!joinedDef.hasOwnProperty(xWebhooks)) {
                    joinedDef[xWebhooks] = {};
                }
                for (const webhook of Object.keys(openapiXWebhooks)) {
                    joinedDef[xWebhooks][webhook] = openapiXWebhooks[webhook];
                    if (!potentialConflicts.xWebhooks.hasOwnProperty(webhook)) {
                        potentialConflicts.xWebhooks[webhook] = {};
                    }
                    for (const operation of Object.keys(openapiXWebhooks[webhook])) {
                        potentialConflicts.xWebhooks[webhook][operation] = [
                            ...(potentialConflicts.xWebhooks[webhook][operation] || []),
                            api,
                        ];
                    }
                    for (const operationKey of Object.keys(joinedDef[xWebhooks][webhook])) {
                        const { tags } = joinedDef[xWebhooks][webhook][operationKey];
                        if (tags) {
                            joinedDef[xWebhooks][webhook][operationKey].tags = tags.map((tag) => addPrefix(tag, tagsPrefix));
                            populateTags({
                                api,
                                apiFilename,
                                tags: formatTags(tags),
                                potentialConflicts,
                                tagsPrefix,
                                componentsPrefix,
                            });
                        }
                    }
                }
            }
        }
        function addInfoSectionAndSpecVersion(documents, prefixComponentsWithInfoProp) {
            var _a;
            const firstApi = documents[0];
            const openapi = firstApi.parsed;
            const componentsPrefix = getInfoPrefix(openapi.info, prefixComponentsWithInfoProp, COMPONENTS);
            if (!openapi.openapi)
                utils_1.exitWithError('Version of specification is not found in. \n');
            if (!openapi.info)
                utils_1.exitWithError('Info section is not found in specification. \n');
            if ((_a = openapi.info) === null || _a === void 0 ? void 0 : _a.description) {
                openapi.info.description = addComponentsPrefix(openapi.info.description, componentsPrefix);
            }
            joinedDef.openapi = openapi.openapi;
            joinedDef.info = openapi.info;
        }
    });
}
exports.handleJoin = handleJoin;
function doesComponentsDiffer(curr, next) {
    return !isEqual(Object.values(curr)[0], Object.values(next)[0]);
}
function validateComponentsDifference(files) {
    let isDiffer = false;
    for (let i = 0, len = files.length; i < len; i++) {
        const next = files[i + 1];
        if (next && doesComponentsDiffer(files[i], next)) {
            isDiffer = true;
        }
    }
    return isDiffer;
}
function iteratePotentialConflicts(potentialConflicts, withoutXTagGroups) {
    for (const group of Object.keys(potentialConflicts)) {
        for (const [key, value] of Object.entries(potentialConflicts[group])) {
            const conflicts = filterConflicts(value);
            if (conflicts.length) {
                if (group === COMPONENTS) {
                    for (const [_, conflict] of Object.entries(conflicts)) {
                        if (validateComponentsDifference(conflict[1])) {
                            conflict[1] = conflict[1].map((c) => Object.keys(c)[0]);
                            showConflicts(colorette_1.green(group) + ' => ' + key, [conflict]);
                            potentialConflictsTotal += 1;
                        }
                    }
                }
                else {
                    if (withoutXTagGroups && group === 'tags') {
                        duplicateTagDescriptionWarning(conflicts);
                    }
                    else {
                        potentialConflictsTotal += conflicts.length;
                        showConflicts(colorette_1.green(group) + ' => ' + key, conflicts);
                    }
                }
                if (group === 'tags' && !withoutXTagGroups) {
                    prefixTagSuggestion(conflicts.length);
                }
            }
        }
    }
}
function duplicateTagDescriptionWarning(conflicts) {
    const tagsKeys = conflicts.map(([tagName]) => `\`${tagName}\``);
    const joinString = colorette_1.yellow(', ');
    process.stderr.write(colorette_1.yellow(`\nwarning: ${tagsKeys.length} conflict(s) on the ${colorette_1.red(tagsKeys.join(joinString))} tags description.\n`));
}
function prefixTagSuggestion(conflictsLength) {
    process.stderr.write(colorette_1.green(`\n${conflictsLength} conflict(s) on tags.\nSuggestion: please use ${colorette_1.blue('prefix-tags-with-filename')}, ${colorette_1.blue('prefix-tags-with-info-prop')} or ${colorette_1.blue('without-x-tag-groups')} to prevent naming conflicts.\n\n`));
}
function showConflicts(key, conflicts) {
    for (const [path, files] of conflicts) {
        process.stderr.write(colorette_1.yellow(`Conflict on ${key} : ${colorette_1.red(path)} in files: ${colorette_1.blue(files)} \n`));
    }
}
function filterConflicts(entities) {
    return Object.entries(entities).filter(([_, files]) => files.length > 1);
}
function getApiFilename(filePath) {
    return path.basename(filePath, path.extname(filePath));
}
function addPrefix(tag, tagsPrefix) {
    return tagsPrefix ? tagsPrefix + '_' + tag : tag;
}
function formatTags(tags) {
    return tags.map((tag) => ({ name: tag }));
}
function addComponentsPrefix(description, componentsPrefix) {
    return description.replace(/"(#\/components\/.*?)"/g, (match) => {
        const componentName = path.basename(match);
        return match.replace(componentName, addPrefix(componentName, componentsPrefix));
    });
}
function addSecurityPrefix(security, componentsPrefix) {
    return componentsPrefix
        ? security === null || security === void 0 ? void 0 : security.map((s) => {
            const key = Object.keys(s)[0];
            return { [componentsPrefix + '_' + key]: s[key] };
        })
        : security;
}
function getInfoPrefix(info, prefixArg, type) {
    if (!prefixArg)
        return '';
    if (!info)
        utils_1.exitWithError('Info section is not found in specification. \n');
    if (!info[prefixArg])
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value is not found in info section. \n`);
    if (!js_utils_1.isString(info[prefixArg]))
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value should be string. \n\n`);
    if (info[prefixArg].length > 50)
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value length should not exceed 50 characters. \n\n`);
    return info[prefixArg];
}
function validateApi(document, config, externalRefResolver, packageVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const results = yield openapi_core_1.lintDocument({ document, config, externalRefResolver });
            const fileTotals = openapi_core_1.getTotals(results);
            openapi_core_1.formatProblems(results, { format: 'stylish', totals: fileTotals, version: packageVersion });
            utils_1.printLintTotals(fileTotals, 2);
        }
        catch (err) {
            utils_1.handleError(err, document.parsed);
        }
    });
}
function crawl(object, visitor) {
    if (!js_utils_1.isObject(object))
        return;
    for (const key of Object.keys(object)) {
        visitor(object, key);
        crawl(object[key], visitor);
    }
}
function replace$Refs(obj, componentsPrefix) {
    crawl(obj, (node) => {
        if (node.$ref && js_utils_1.isString(node.$ref) && node.$ref.startsWith(`#/${COMPONENTS}/`)) {
            const name = path.basename(node.$ref);
            node.$ref = node.$ref.replace(name, componentsPrefix + '_' + name);
        }
        else if (node.discriminator &&
            node.discriminator.mapping &&
            js_utils_1.isObject(node.discriminator.mapping)) {
            const { mapping } = node.discriminator;
            for (const name of Object.keys(mapping)) {
                if (js_utils_1.isString(mapping[name]) && mapping[name].startsWith(`#/${COMPONENTS}/`)) {
                    mapping[name] = mapping[name]
                        .split('/')
                        .map((name, i, arr) => {
                        return arr.length - 1 === i && !name.includes(componentsPrefix)
                            ? componentsPrefix + '_' + name
                            : name;
                    })
                        .join('/');
                }
            }
        }
    });
}
