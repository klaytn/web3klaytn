"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iteratePathItems = exports.handleSplit = void 0;
const colorette_1 = require("colorette");
const fs = require("fs");
const openapi_core_1 = require("@redocly/openapi-core");
const path = require("path");
const perf_hooks_1 = require("perf_hooks");
const isEqual = require('lodash.isequal');
const utils_1 = require("../../utils");
const js_utils_1 = require("../../js-utils");
const types_1 = require("./types");
function handleSplit(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const startedAt = perf_hooks_1.performance.now();
        const { api, outDir, separator } = argv;
        validateDefinitionFileName(api);
        const openapi = utils_1.readYaml(api);
        splitDefinition(openapi, outDir, separator);
        process.stderr.write(`ðŸª“ Document: ${colorette_1.blue(api)} ${colorette_1.green('is successfully split')}
    and all related files are saved to the directory: ${colorette_1.blue(outDir)} \n`);
        utils_1.printExecutionTime('split', startedAt, api);
    });
}
exports.handleSplit = handleSplit;
function splitDefinition(openapi, openapiDir, pathSeparator) {
    fs.mkdirSync(openapiDir, { recursive: true });
    const componentsFiles = {};
    iterateComponents(openapi, openapiDir, componentsFiles);
    iteratePathItems(openapi.paths, openapiDir, path.join(openapiDir, 'paths'), componentsFiles, pathSeparator);
    const webhooks = openapi.webhooks || openapi['x-webhooks'];
    // use webhook_ prefix for code samples to prevent potential name-clashes with paths samples
    iteratePathItems(webhooks, openapiDir, path.join(openapiDir, 'webhooks'), componentsFiles, pathSeparator, 'webhook_');
    replace$Refs(openapi, openapiDir, componentsFiles);
    utils_1.writeYaml(openapi, path.join(openapiDir, 'openapi.yaml'));
}
function isStartsWithComponents(node) {
    return node.startsWith(types_1.componentsPath);
}
function isNotYaml(filename) {
    return !(filename.endsWith('.yaml') || filename.endsWith('.yml'));
}
function loadFile(fileName) {
    try {
        return openapi_core_1.parseYaml(fs.readFileSync(fileName, 'utf8'));
    }
    catch (e) {
        return utils_1.exitWithError(e.message);
    }
}
function validateDefinitionFileName(fileName) {
    if (!fs.existsSync(fileName))
        utils_1.exitWithError(`File ${colorette_1.blue(fileName)} does not exist \n`);
    const file = loadFile(fileName);
    if (file.swagger)
        utils_1.exitWithError('OpenAPI 2 is not supported by this command');
    if (!file.openapi)
        utils_1.exitWithError('File does not conform to the OpenAPI Specification. OpenAPI version is not specified');
    return true;
}
function traverseDirectoryDeep(directory, callback, componentsFiles) {
    if (!fs.existsSync(directory) || !fs.statSync(directory).isDirectory())
        return;
    const files = fs.readdirSync(directory);
    for (const f of files) {
        const filename = path.join(directory, f);
        if (fs.statSync(filename).isDirectory()) {
            traverseDirectoryDeep(filename, callback, componentsFiles);
        }
        else {
            callback(filename, directory, componentsFiles);
        }
    }
}
function traverseDirectoryDeepCallback(filename, directory, componentsFiles) {
    if (isNotYaml(filename))
        return;
    const pathData = utils_1.readYaml(filename);
    replace$Refs(pathData, directory, componentsFiles);
    utils_1.writeYaml(pathData, filename);
}
function crawl(object, visitor) {
    if (!js_utils_1.isObject(object))
        return;
    for (const key of Object.keys(object)) {
        visitor(object, key);
        crawl(object[key], visitor);
    }
}
function replace$Refs(obj, relativeFrom, componentFiles = {}) {
    crawl(obj, (node) => {
        if (node.$ref && js_utils_1.isString(node.$ref) && isStartsWithComponents(node.$ref)) {
            replace(node, '$ref');
        }
        else if (node.discriminator &&
            node.discriminator.mapping &&
            js_utils_1.isObject(node.discriminator.mapping)) {
            const { mapping } = node.discriminator;
            for (const name of Object.keys(mapping)) {
                if (js_utils_1.isString(mapping[name]) && isStartsWithComponents(mapping[name])) {
                    replace(node.discriminator.mapping, name);
                }
            }
        }
    });
    function replace(node, key) {
        const splittedNode = node[key].split('/');
        const name = splittedNode.pop();
        const groupName = splittedNode[2];
        const filesGroupName = componentFiles[groupName];
        if (!filesGroupName || !filesGroupName[name])
            return;
        let filename = path.relative(relativeFrom, filesGroupName[name].filename);
        if (!filename.startsWith('.')) {
            filename = '.' + path.sep + filename;
        }
        node[key] = filename;
    }
}
function implicitlyReferenceDiscriminator(obj, defName, filename, schemaFiles) {
    if (!obj.discriminator)
        return;
    const defPtr = `#/${types_1.COMPONENTS}/${types_1.OPENAPI3_COMPONENT.Schemas}/${defName}`;
    const implicitMapping = {};
    for (const [name, { inherits, filename: parentFilename }] of Object.entries(schemaFiles)) {
        if (inherits.indexOf(defPtr) > -1) {
            const res = path.relative(path.dirname(filename), parentFilename);
            implicitMapping[name] = res.startsWith('.') ? res : '.' + path.sep + res;
        }
    }
    if (js_utils_1.isEmptyObject(implicitMapping))
        return;
    const discriminatorPropSchema = obj.properties[obj.discriminator.propertyName];
    const discriminatorEnum = discriminatorPropSchema && discriminatorPropSchema.enum;
    const mapping = (obj.discriminator.mapping = obj.discriminator.mapping || {});
    for (const name of Object.keys(implicitMapping)) {
        if (discriminatorEnum && !discriminatorEnum.includes(name)) {
            continue;
        }
        if (mapping[name] && mapping[name] !== implicitMapping[name]) {
            process.stderr.write(colorette_1.yellow(`warning: explicit mapping overlaps with local mapping entry ${colorette_1.red(name)} at ${colorette_1.blue(filename)}. Please check it.`));
        }
        mapping[name] = implicitMapping[name];
    }
}
function isNotSecurityComponentType(componentType) {
    return componentType !== types_1.OPENAPI3_COMPONENT.SecuritySchemes;
}
function findComponentTypes(components) {
    return types_1.OPENAPI3_COMPONENT_NAMES.filter((item) => isNotSecurityComponentType(item) && Object.keys(components).includes(item));
}
function doesFileDiffer(filename, componentData) {
    return fs.existsSync(filename) && !isEqual(utils_1.readYaml(filename), componentData);
}
function removeEmptyComponents(openapi, componentType) {
    if (openapi.components && js_utils_1.isEmptyObject(openapi.components[componentType])) {
        delete openapi.components[componentType];
    }
    if (js_utils_1.isEmptyObject(openapi.components)) {
        delete openapi.components;
    }
}
function createComponentDir(componentDirPath, componentType) {
    if (isNotSecurityComponentType(componentType)) {
        fs.mkdirSync(componentDirPath, { recursive: true });
    }
}
function extractFileNameFromPath(filename) {
    return path.basename(filename, path.extname(filename));
}
function getFileNamePath(componentDirPath, componentName) {
    return path.join(componentDirPath, componentName) + '.yaml';
}
function gatherComponentsFiles(components, componentsFiles, componentType, componentName, filename) {
    var _a, _b;
    let inherits = [];
    if (componentType === types_1.OPENAPI3_COMPONENT.Schemas) {
        inherits = (((_b = (_a = components === null || components === void 0 ? void 0 : components[componentType]) === null || _a === void 0 ? void 0 : _a[componentName]) === null || _b === void 0 ? void 0 : _b.allOf) || [])
            .map(({ $ref }) => $ref)
            .filter(openapi_core_1.isTruthy);
    }
    componentsFiles[componentType] = componentsFiles[componentType] || {};
    componentsFiles[componentType][componentName] = { inherits, filename };
}
function iteratePathItems(pathItems, openapiDir, outDir, componentsFiles, pathSeparator, codeSamplesPathPrefix = '') {
    if (!pathItems)
        return;
    fs.mkdirSync(outDir, { recursive: true });
    for (const pathName of Object.keys(pathItems)) {
        const pathFile = `${path.join(outDir, utils_1.pathToFilename(pathName, pathSeparator))}.yaml`;
        const pathData = pathItems[pathName];
        if (openapi_core_1.isRef(pathData))
            continue;
        for (const method of types_1.OPENAPI3_METHOD_NAMES) {
            const methodData = pathData[method];
            const methodDataXCode = (methodData === null || methodData === void 0 ? void 0 : methodData['x-code-samples']) || (methodData === null || methodData === void 0 ? void 0 : methodData['x-codeSamples']);
            if (!methodDataXCode || !Array.isArray(methodDataXCode)) {
                continue;
            }
            for (const sample of methodDataXCode) {
                if (sample.source && sample.source.$ref)
                    continue;
                const sampleFileName = path.join(openapiDir, 'code_samples', utils_1.escapeLanguageName(sample.lang), codeSamplesPathPrefix + utils_1.pathToFilename(pathName, pathSeparator), method + utils_1.langToExt(sample.lang));
                fs.mkdirSync(path.dirname(sampleFileName), { recursive: true });
                fs.writeFileSync(sampleFileName, sample.source);
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                sample.source = {
                    $ref: openapi_core_1.slash(path.relative(outDir, sampleFileName)),
                };
            }
        }
        utils_1.writeYaml(pathData, pathFile);
        pathItems[pathName] = {
            $ref: openapi_core_1.slash(path.relative(openapiDir, pathFile)),
        };
        traverseDirectoryDeep(outDir, traverseDirectoryDeepCallback, componentsFiles);
    }
}
exports.iteratePathItems = iteratePathItems;
function iterateComponents(openapi, openapiDir, componentsFiles) {
    const { components } = openapi;
    if (components) {
        const componentsDir = path.join(openapiDir, types_1.COMPONENTS);
        fs.mkdirSync(componentsDir, { recursive: true });
        const componentTypes = findComponentTypes(components);
        componentTypes.forEach(iterateAndGatherComponentsFiles);
        componentTypes.forEach(iterateComponentTypes);
        // eslint-disable-next-line no-inner-declarations
        function iterateAndGatherComponentsFiles(componentType) {
            const componentDirPath = path.join(componentsDir, componentType);
            for (const componentName of Object.keys((components === null || components === void 0 ? void 0 : components[componentType]) || {})) {
                const filename = getFileNamePath(componentDirPath, componentName);
                gatherComponentsFiles(components, componentsFiles, componentType, componentName, filename);
            }
        }
        // eslint-disable-next-line no-inner-declarations
        function iterateComponentTypes(componentType) {
            var _a, _b, _c;
            const componentDirPath = path.join(componentsDir, componentType);
            createComponentDir(componentDirPath, componentType);
            for (const componentName of Object.keys((components === null || components === void 0 ? void 0 : components[componentType]) || {})) {
                const filename = getFileNamePath(componentDirPath, componentName);
                const componentData = (_a = components === null || components === void 0 ? void 0 : components[componentType]) === null || _a === void 0 ? void 0 : _a[componentName];
                replace$Refs(componentData, path.dirname(filename), componentsFiles);
                implicitlyReferenceDiscriminator(componentData, extractFileNameFromPath(filename), filename, componentsFiles.schemas || {});
                if (doesFileDiffer(filename, componentData)) {
                    process.stderr.write(colorette_1.yellow(`warning: conflict for ${componentName} - file already exists with different content: ${colorette_1.blue(filename)} ... Skip.\n`));
                }
                else {
                    utils_1.writeYaml(componentData, filename);
                }
                if (isNotSecurityComponentType(componentType)) {
                    // security schemas must referenced from components
                    (_c = (_b = openapi.components) === null || _b === void 0 ? void 0 : _b[componentType]) === null || _c === void 0 ? true : delete _c[componentName];
                }
            }
            removeEmptyComponents(openapi, componentType);
        }
    }
}
